from Crypto.Hash import SHA256
from Crypto.PublicKey import ECC
from Crypto.Signature import DSS
from Crypto.Util.asn1 import DerSequence
from eth_account import Account
from eth_account.messages import encode_defunct
from eth_keys.validation import ValidationError
from eth_keys.datatypes import PublicKey

from .file_util import FileUtil


_file_util = FileUtil()


def verify_create_hashes(asset_path: str, data: dict) -> bool:
    """Verify asset hashes in the data sent to the create action.

    Args:
        asset_path: the local path to the asset file
        data: dictionary with the 'meta' and 'signature' sections of the request

    Returns:
        True if the hashes matched the asset, False if not

    Raises:
        ValueError or KeyError if fields are missing
        Exception if hashes aren't all the same in the JSON
        File I/O errors if there's an issue reading the asset file
    """

    if data.get("meta") is None:
        raise ValueError("meta must be present, but got None")
    if data.get("signature") is None:
        raise ValueError("signature must be present, but got None")

    # First check all hashes match

    meta_hash = data["meta"]["proof"]["hash"]
    sig_hash = data["signature"][0]["proofHash"]

    if meta_hash != sig_hash:
        raise Exception("The meta hash does not equal the first signature hash")

    if len(data["signature"]) > 1:
        # Check all hashes for each signature match
        for sig in data["signatures"][1:]:
            if sig.get("proofHash") != sig_hash:
                raise Exception("Not all proofHash fields of signatures match")

    # Now actually verify the hash
    asset_hash = _file_util.digest_sha256(asset_path)
    return sig_hash == asset_hash


def verify_all(meta_raw: str, signatures: dict) -> bool:
    """Verify all signatures.

    Args:
        meta_raw: string containing JSON meta information, unmodified from POST
                  request
        signatures: 'signature' section of the request data

    Returns:
        True if all signatures verified, False if not

    Raises:
        NotImplementedError if one of the signature providers is not recognized
        Any errors raised due to signature bytes being malformed
    """

    for sig in signatures:
        if sig["provider"] == "AndroidOpenSSL":
            if not _verify_androidopenssl(meta_raw, sig):
                return False
        elif sig["provider"] == "Zion":
            if not _verify_zion(meta_raw, sig):
                return False
        else:
            raise NotImplementedError(f"Provider {sig['provider']} not implemented")

    return True


def _verify_androidopenssl(meta_raw: str, signature: dict) -> bool:
    # Adapted from signature verification example
    # https://www.pycryptodome.org/en/latest/src/signature/dsa.html

    key = ECC.import_key(bytes.fromhex(signature["publicKey"]))
    h = SHA256.new(meta_raw.encode())
    verifier = DSS.new(key, "fips-186-3", encoding="der")
    try:
        verifier.verify(h, bytes.fromhex(signature["signature"]))
        return True
    except ValueError:
        return False


def _verify_zion(meta_raw: str, signature: dict) -> bool:
    # Content of publicKey field is generated by app
    # Source code is here: https://github.com/starlinglab/starling-capture/blob/fbf55abb205444d5f067d048ff5c5c89682f94b4/app/src/main/java/io/numbersprotocol/starlingcapture/collector/zion/ZionSessionSignatureProvider.kt#L24-L40
    # Either the publicKey field starts with "Session" and the data is signed
    # by an ecdsa session key, or it starts with "Receive" and then the data is
    # signed with an ethereum signature thing.

    if signature["publicKey"].startswith("Session"):
        # Same as _verify_androidopenssl
        key = ECC.import_key(
            bytes.fromhex(
                # Extract key from after "Session" label
                # 182 is the length of a hex-encoded, DER-encoded ec key
                signature["publicKey"][len("Session:\n") : len("Session:\n") + 182 + 1]
            )
        )
        h = SHA256.new(meta_raw.encode())
        verifier = DSS.new(key, "fips-186-3", encoding="der")
        try:
            verifier.verify(h, bytes.fromhex(signature["signature"]))
            return True
        except ValueError:
            return False

    elif signature["publicKey"].startswith("Receive"):
        # Ethereum signature using ethereum key
        # Result is ethereum address

        message = encode_defunct(text=meta_raw)

        # Signature is DER-encoded but recover_message wants the individual numbers
        # So decode the DER and extract the numbers
        #
        # DER decode from https://www.pycryptodome.org/en/latest/src/util/asn1.html#Crypto.Util.asn1.DerSequence

        # TODO: the signature might look different then this code expects!
        # This hasn't been tested yet

        seq_der = DerSequence()
        seq_der.decode(bytes.fromhex(signature["signature"]))
        # Signature contains r and s, part of an elliptic curve sig
        r = hex(seq_der[0])
        s = hex(seq_der[1])
        v = 28  # Not included in sig, but constant

        # Ethereum address the signature belongs to
        addr = Account.recover_message(message, vrs=(v, r, s))
        # Signer's Ethereum address
        pk = PublicKey.from_compressed_bytes(
            bytes.fromhex(signature["publicKey"][-66:])
        )
        return addr == pk.to_checksum_address()

    else:
        raise Exception(
            "Zion publicKey doesn't start with Session or Receive, unable to parse"
        )
